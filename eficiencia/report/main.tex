\documentclass{article}
\usepackage[left=3cm,right=3cm,top=2.5cm,bottom=2cm]{geometry} % page settings
\usepackage{amsmath} % provides many mathematical environments & tools
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage[spanish]{babel}



\usepackage{multirow}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{pifont}

\usepackage[utf8]{inputenc}
\setlength{\parindent}{0mm}

\usepackage[parfill]{parskip}

% Para el código
\usepackage{listings}
\usepackage{xcolor}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\newcommand{\n}[1]{{\color{gray}#1}}
\lstset{numbers=left,numberstyle=\small\color{gray}}

% Entorno para estilo de ejercicios
\setlength{\parindent}{0pt}

\usepackage{color}   %May be necessary if you want to color links
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}

\usepackage{graphicx}
\usepackage{subfig}

\begin{document}

\title{%
  \huge Análisis de la eficiencia de algoritmos \\[5mm]
  \Large Algorítmica\\
  \normalsize Doble Grado en Ingeniería Informática y Matemáticas\\[5cm]
}
\author{Yábir García Benchakhtir \\ yabirgb@correo.ugr.es \\[10cm]}

\date{\today}
\maketitle

\newpage
\tableofcontents
\newpage

\section{Análisis de los algoritmos}

\section{Cálculo de la eficiencia empírica}

\subsection{Procedimiento}

Para el cálculo de la eficiencia empírica se ha automatizado el
proceso. Para ellos se han hecho 2 scripts de bash y un archivo
makefile para realizar las siguientes tareas:

\begin{itemize}
\item Crear archivos ejecutables para todos los algoritmos programados
  en \textit{C++} con distintas opciones de optimización a saber
  \textit{O1}, \textit{O2} y \textit{O3}.
\item Ejecutar los distintos tests para los intervalos programados y
  almacenar los resultados en archivos de datos.
\item Crear las respectivas gráficas para cada tabla de datos obtenida usando la herramienta gnuplot.
\end{itemize}

Para los algoritmos de medición se ha elegido un rango de datos común
en el intervalo [1000, 25000] de manera que se toman 25 medidas
haciendo incrementos de 1000 en 1000 para tomar las medidas.

$$D = \{x \in [1000, 25000]: x = 1000k, k \in \mathbb{N}\}$$

Junto a este documento se encuentran las gráficas creadas y los datos
que proporciona el programa \textit{gnuplot} sobre las mediciones.

A la hora de hacer un ajuste de mínimos cuadrados se han usado las
siguientes funciones de ajuste:

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|}
    \hline
    Complejidad (\textit{Big O}) & Función de ajuste \\ \hline
    $O(n^2)$ & $f(x) = ax^2 + bx + c$ \\ \hline
    $O(n^3)$ & $f(x) = ax^3 + bx^2 + cx + d$ \\ \hline
    $O(nlog(n))$ & $f(x) = a\cdot log(x+b) + c$ \\ \hline
    $O(2^n)$ & $f(x) = a2^x$ \\ \hline


  \end{tabular}
  \caption{Funciones de ajuste}
\end{table}

\subsection{Condiciones de las mediciones}

Para llevar a cabo las mediciones se ha utilizado un ordenador con las
siguientes características:

\begin{itemize}
\item CPU: Intel Pentium G3258 (2) @ 3.200GHz
\item Memoria RAM: 7876MiB
\item Kernel:4.13.0-36-generic
\item OS: Linux Mint 18.3 Sylvia x86\_64
\end{itemize}

A la hora de realizar los tests se ha tenido la precaución de
minimizar el uso de \textit{CPU} para no interferir en las mediciones.

\section{Resultados obtenidos}

En esta sección de la practica me concentro en mostrar los resultados
obtenidos tras haber completado el proceso de pruebas de los distintos
algoritmos. En este caso muestro los datos con una eficiencia al
compilar \textit{O0}.

\subsection{Algoritmo de ordenación Burbuja}

\input{images/burbuja_0_images}
\subsection{Algoritmo de ordenación por insercción}


\input{images/insercion_0_images}

\subsection{Algoritmo de ordenación por selección}

\input{images/seleccion_0_images}

\subsection{Comparativa de los algoritmos cuadráticos de ordenación}

\subsection{Algoritmo de ordenación mergesort}
\input{images/seleccion_0_images}
\subsection{Algoritmo de ordenación quicksort}
\input{images/quicksort_0_images}
\subsection{Algoritmo de ordenación heapsort}
\input{images/heapsort_0_images}
\subsection{Algoritmo floyd}
\input{images/floyd_0_images}
\subsection{Algoritmo de las torres de Hanoi}
\input{images/hanoi_0_images}

\section{Analisis de los resultados}

\subsection{Comparativa de los algoritmos $O(n^2)$ de ordenación}

\begin{figure}[H]
  \centering   
      \subfloat {%

        \input{tables/ordenacionC0}
        
      }
      
      \subfloat{%
        \includegraphics[clip,width=0.7\columnwidth]{../plots/cuadraticas_O0.png}%
      }



\caption{Comaparación entre los distintos algoritmos de ordenación cuadráticos}
\end{figure}


\subsection{Comparativa de los algoritmos $nlog(n)$ de ordenación}

\begin{figure}[H]
  \centering   
      \subfloat {%

        \input{tables/ordenacionL0}
        
      }
      
      \subfloat{%
        \includegraphics[clip,width=0.7\columnwidth]{../plots/logaritmicos_O0.png}%
      }
      \caption{Comaparación entre los distintos algoritmos de ordenación $nlogn$}
\end{figure}

\subsection{Comparativa de los algoritmos de ordenación}

\begin{figure}[H]
  \centering   
      \subfloat {%
        \input{tables/ordenacionTodos0}
      }
      
      \subfloat{%
        \includegraphics[clip,width=0.7\columnwidth]{../plots/todos_ordenacion_O0.png}%
      }
      \caption{Comaparación entre los distintos algoritmos de ordenación $nlogn$}
\end{figure}

De los resultados obtenidos podemos ver de forma clara como el
algoritmo de burbuja es el que desempeña la tarea de forma
considerablemente más lenta.

Entre los algoritmos de selección e insercción no encontramos mucha
diferencia aunque son notoriamente más eficientes que el de burbuja.

Finalmente los algoritmos de orden $O(n\cdot log(n))$ son mucho más
eficientes que el resto aunque podemos observar como el algoritmo
quicksort ha sido el que ha obtenido mejores resultados pese a ser del
mismo orden de eficiencia.

En el algoritmo de hanoi podemos observar como al ser $O(2^n)$ el
tiempo que tarda en ejecutarse crece rapidamente a partir de un punto
lo cual nos permite realizar únicamente pocas iteraciones.

\end{document}